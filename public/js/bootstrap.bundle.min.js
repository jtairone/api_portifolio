/*!
  * Bootstrap v4.6.1 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? e(exports, require('jquery')) : typeof define === 'function' && define.amd ? define(['exports', 'jquery'], e) : e((t = typeof globalThis !== 'undefined' ? globalThis : t || self).bootstrap = {}, t.jQuery) }(this, ((t, e) => {
    function n(t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const i = n(e); function o(t, e) { for (let n = 0; n < e.length; n++) { const i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function r(t, e, n) { return e && o(t.prototype, e), n && o(t, n), t } function a() { return a = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, a.apply(this, arguments) } function s(t, e) { return s = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t }, s(t, e) } const l = 'transitionend'; var u = {
        TRANSITION_END: 'bsTransitionEnd', getUID(t) { do { t += ~~(1e6 * Math.random()) } while (document.getElementById(t)); return t }, getSelectorFromElement(t) { let e = t.getAttribute('data-target'); if (!e || e === '#') { const n = t.getAttribute('href'); e = n && n !== '#' ? n.trim() : '' } try { return document.querySelector(e) ? e : null } catch (t) { return null } }, getTransitionDurationFromElement(t) { if (!t) return 0; let e = i.default(t).css('transition-duration'); let n = i.default(t).css('transition-delay'); const o = parseFloat(e); const r = parseFloat(n); return o || r ? (e = e.split(',')[0], n = n.split(',')[0], 1e3 * (parseFloat(e) + parseFloat(n))) : 0 }, reflow(t) { return t.offsetHeight }, triggerTransitionEnd(t) { i.default(t).trigger(l) }, supportsTransitionEnd() { return Boolean(l) }, isElement(t) { return (t[0] || t).nodeType }, typeCheckConfig(t, e, n) { for (const i in n) if (Object.prototype.hasOwnProperty.call(n, i)) { const o = n[i]; const r = e[i]; const a = r && u.isElement(r) ? 'element' : (s = r) === null || typeof s === 'undefined' ? `${s}` : {}.toString.call(s).match(/\s([a-z]+)/i)[1].toLowerCase(); if (!new RegExp(o).test(a)) throw new Error(`${t.toUpperCase()}: Option "${i}" provided type "${a}" but expected type "${o}".`) } let s }, findShadowRoot(t) { if (!document.documentElement.attachShadow) return null; if (typeof t.getRootNode === 'function') { const e = t.getRootNode(); return e instanceof ShadowRoot ? e : null } return t instanceof ShadowRoot ? t : t.parentNode ? u.findShadowRoot(t.parentNode) : null }, jQueryDetection() { if (typeof i.default === 'undefined') throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript."); const t = i.default.fn.jquery.split(' ')[0].split('.'); if (t[0] < 2 && t[1] < 9 || t[0] === 1 && t[1] === 9 && t[2] < 1 || t[0] >= 4) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0") },
    }; u.jQueryDetection(), i.default.fn.emulateTransitionEnd = function (t) { const e = this; let n = !1; return i.default(this).one(u.TRANSITION_END, (() => { n = !0 })), setTimeout((() => { n || u.triggerTransitionEnd(e) }), t), this }, i.default.event.special[u.TRANSITION_END] = { bindType: l, delegateType: l, handle(t) { if (i.default(t.target).is(this)) return t.handleObj.handler.apply(this, arguments) } }; const f = 'bs.alert'; const d = i.default.fn.alert; const c = (function () { function t(t) { this._element = t } const e = t.prototype; return e.close = function (t) { let e = this._element; t && (e = this._getRootElement(t)), this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e) }, e.dispose = function () { i.default.removeData(this._element, f), this._element = null }, e._getRootElement = function (t) { const e = u.getSelectorFromElement(t); let n = !1; return e && (n = document.querySelector(e)), n || (n = i.default(t).closest('.alert')[0]), n }, e._triggerCloseEvent = function (t) { const e = i.default.Event('close.bs.alert'); return i.default(t).trigger(e), e }, e._removeElement = function (t) { const e = this; if (i.default(t).removeClass('show'), i.default(t).hasClass('fade')) { const n = u.getTransitionDurationFromElement(t); i.default(t).one(u.TRANSITION_END, ((n) => e._destroyElement(t, n))).emulateTransitionEnd(n) } else this._destroyElement(t) }, e._destroyElement = function (t) { i.default(t).detach().trigger('closed.bs.alert').remove() }, t._jQueryInterface = function (e) { return this.each((function () { const n = i.default(this); let o = n.data(f); o || (o = new t(this), n.data(f, o)), e === 'close' && o[e](this) })) }, t._handleDismiss = function (t) { return function (e) { e && e.preventDefault(), t.close(this) } }, r(t, null, [{ key: 'VERSION', get() { return '4.6.1' } }]), t }()); i.default(document).on('click.bs.alert.data-api', '[data-dismiss="alert"]', c._handleDismiss(new c())), i.default.fn.alert = c._jQueryInterface, i.default.fn.alert.Constructor = c, i.default.fn.alert.noConflict = function () { return i.default.fn.alert = d, c._jQueryInterface }; const h = 'bs.button'; const p = i.default.fn.button; const m = 'active'; const g = '[data-toggle^="button"]'; const _ = 'input:not([type="hidden"])'; const v = '.btn'; const b = (function () { function t(t) { this._element = t, this.shouldAvoidTriggerChange = !1 } const e = t.prototype; return e.toggle = function () { let t = !0; let e = !0; const n = i.default(this._element).closest('[data-toggle="buttons"]')[0]; if (n) { const o = this._element.querySelector(_); if (o) { if (o.type === 'radio') if (o.checked && this._element.classList.contains(m))t = !1; else { const r = n.querySelector('.active'); r && i.default(r).removeClass(m) }t && (o.type !== 'checkbox' && o.type !== 'radio' || (o.checked = !this._element.classList.contains(m)), this.shouldAvoidTriggerChange || i.default(o).trigger('change')), o.focus(), e = !1 } } this._element.hasAttribute('disabled') || this._element.classList.contains('disabled') || (e && this._element.setAttribute('aria-pressed', !this._element.classList.contains(m)), t && i.default(this._element).toggleClass(m)) }, e.dispose = function () { i.default.removeData(this._element, h), this._element = null }, t._jQueryInterface = function (e, n) { return this.each((function () { const o = i.default(this); let r = o.data(h); r || (r = new t(this), o.data(h, r)), r.shouldAvoidTriggerChange = n, e === 'toggle' && r[e]() })) }, r(t, null, [{ key: 'VERSION', get() { return '4.6.1' } }]), t }()); i.default(document).on('click.bs.button.data-api', g, ((t) => { let e = t.target; const n = e; if (i.default(e).hasClass('btn') || (e = i.default(e).closest(v)[0]), !e || e.hasAttribute('disabled') || e.classList.contains('disabled'))t.preventDefault(); else { const o = e.querySelector(_); if (o && (o.hasAttribute('disabled') || o.classList.contains('disabled'))) return void t.preventDefault(); n.tagName !== 'INPUT' && e.tagName === 'LABEL' || b._jQueryInterface.call(i.default(e), 'toggle', n.tagName === 'INPUT') } })).on('focus.bs.button.data-api blur.bs.button.data-api', g, ((t) => { const e = i.default(t.target).closest(v)[0]; i.default(e).toggleClass('focus', /^focus(in)?$/.test(t.type)) })), i.default(window).on('load.bs.button.data-api', (() => { for (var t = [].slice.call(document.querySelectorAll('[data-toggle="buttons"] .btn')), e = 0, n = t.length; e < n; e++) { const i = t[e]; const o = i.querySelector(_); o.checked || o.hasAttribute('checked') ? i.classList.add(m) : i.classList.remove(m) } for (let r = 0, a = (t = [].slice.call(document.querySelectorAll('[data-toggle="button"]'))).length; r < a; r++) { const s = t[r]; s.getAttribute('aria-pressed') === 'true' ? s.classList.add(m) : s.classList.remove(m) } })), i.default.fn.button = b._jQueryInterface, i.default.fn.button.Constructor = b, i.default.fn.button.noConflict = function () { return i.default.fn.button = p, b._jQueryInterface }; const y = 'carousel'; const E = 'bs.carousel'; const w = i.default.fn[y]; const T = 'active'; const C = 'next'; const S = 'prev'; const N = 'slid.bs.carousel'; const D = '.active.carousel-item'; const A = {
        interval: 5e3, keyboard: !0, slide: !1, pause: 'hover', wrap: !0, touch: !0,
    }; const k = {
        interval: '(number|boolean)', keyboard: 'boolean', slide: '(boolean|string)', pause: '(string|boolean)', wrap: 'boolean', touch: 'boolean',
    }; const I = { TOUCH: 'touch', PEN: 'pen' }; const O = (function () {
        function t(t, e) { this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._element = t, this._indicatorsElement = this._element.querySelector('.carousel-indicators'), this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent), this._addEventListeners() } const e = t.prototype; return e.next = function () { this._isSliding || this._slide(C) }, e.nextWhenVisible = function () { const t = i.default(this._element); !document.hidden && t.is(':visible') && t.css('visibility') !== 'hidden' && this.next() }, e.prev = function () { this._isSliding || this._slide(S) }, e.pause = function (t) { t || (this._isPaused = !0), this._element.querySelector('.carousel-item-next, .carousel-item-prev') && (u.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null }, e.cycle = function (t) { t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)) }, e.to = function (t) { const e = this; this._activeElement = this._element.querySelector(D); const n = this._getItemIndex(this._activeElement); if (!(t > this._items.length - 1 || t < 0)) if (this._isSliding)i.default(this._element).one(N, (() => e.to(t))); else { if (n === t) return this.pause(), void this.cycle(); const o = t > n ? C : S; this._slide(o, this._items[t]) } }, e.dispose = function () { i.default(this._element).off('.bs.carousel'), i.default.removeData(this._element, E), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null }, e._getConfig = function (t) { return t = { ...A, ...t }, u.typeCheckConfig(y, t, k), t }, e._handleSwipe = function () { const t = Math.abs(this.touchDeltaX); if (!(t <= 40)) { const e = t / this.touchDeltaX; this.touchDeltaX = 0, e > 0 && this.prev(), e < 0 && this.next() } }, e._addEventListeners = function () { const t = this; this._config.keyboard && i.default(this._element).on('keydown.bs.carousel', ((e) => t._keydown(e))), this._config.pause === 'hover' && i.default(this._element).on('mouseenter.bs.carousel', ((e) => t.pause(e))).on('mouseleave.bs.carousel', ((e) => t.cycle(e))), this._config.touch && this._addTouchEventListeners() }, e._addTouchEventListeners = function () { const t = this; if (this._touchSupported) { const e = function (e) { t._pointerEvent && I[e.originalEvent.pointerType.toUpperCase()] ? t.touchStartX = e.originalEvent.clientX : t._pointerEvent || (t.touchStartX = e.originalEvent.touches[0].clientX) }; const n = function (e) { t._pointerEvent && I[e.originalEvent.pointerType.toUpperCase()] && (t.touchDeltaX = e.originalEvent.clientX - t.touchStartX), t._handleSwipe(), t._config.pause === 'hover' && (t.pause(), t.touchTimeout && clearTimeout(t.touchTimeout), t.touchTimeout = setTimeout(((e) => t.cycle(e)), 500 + t._config.interval)) }; i.default(this._element.querySelectorAll('.carousel-item img')).on('dragstart.bs.carousel', ((t) => t.preventDefault())), this._pointerEvent ? (i.default(this._element).on('pointerdown.bs.carousel', ((t) => e(t))), i.default(this._element).on('pointerup.bs.carousel', ((t) => n(t))), this._element.classList.add('pointer-event')) : (i.default(this._element).on('touchstart.bs.carousel', ((t) => e(t))), i.default(this._element).on('touchmove.bs.carousel', ((e) => (function (e) { t.touchDeltaX = e.originalEvent.touches && e.originalEvent.touches.length > 1 ? 0 : e.originalEvent.touches[0].clientX - t.touchStartX }(e)))), i.default(this._element).on('touchend.bs.carousel', ((t) => n(t)))) } }, e._keydown = function (t) { if (!/input|textarea/i.test(t.target.tagName)) switch (t.which) { case 37: t.preventDefault(), this.prev(); break; case 39: t.preventDefault(), this.next() } }, e._getItemIndex = function (t) { return this._items = t && t.parentNode ? [].slice.call(t.parentNode.querySelectorAll('.carousel-item')) : [], this._items.indexOf(t) }, e._getItemByDirection = function (t, e) { const n = t === C; const i = t === S; const o = this._getItemIndex(e); const r = this._items.length - 1; if ((i && o === 0 || n && o === r) && !this._config.wrap) return e; const a = (o + (t === S ? -1 : 1)) % this._items.length; return a === -1 ? this._items[this._items.length - 1] : this._items[a] }, e._triggerSlideEvent = function (t, e) {
            const n = this._getItemIndex(t); const o = this._getItemIndex(this._element.querySelector(D)); const r = i.default.Event('slide.bs.carousel', {
                relatedTarget: t, direction: e, from: o, to: n,
            }); return i.default(this._element).trigger(r), r
        }, e._setActiveIndicatorElement = function (t) { if (this._indicatorsElement) { const e = [].slice.call(this._indicatorsElement.querySelectorAll('.active')); i.default(e).removeClass(T); const n = this._indicatorsElement.children[this._getItemIndex(t)]; n && i.default(n).addClass(T) } }, e._updateInterval = function () { const t = this._activeElement || this._element.querySelector(D); if (t) { const e = parseInt(t.getAttribute('data-interval'), 10); e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval } }, e._slide = function (t, e) {
            let n; let o; let r; const a = this; const s = this._element.querySelector(D); const l = this._getItemIndex(s); const f = e || s && this._getItemByDirection(t, s); const d = this._getItemIndex(f); const c = Boolean(this._interval); if (t === C ? (n = 'carousel-item-left', o = 'carousel-item-next', r = 'left') : (n = 'carousel-item-right', o = 'carousel-item-prev', r = 'right'), f && i.default(f).hasClass(T)) this._isSliding = !1; else if (!this._triggerSlideEvent(f, r).isDefaultPrevented() && s && f) {
                this._isSliding = !0, c && this.pause(), this._setActiveIndicatorElement(f), this._activeElement = f; const h = i.default.Event(N, {
                    relatedTarget: f, direction: r, from: l, to: d,
                }); if (i.default(this._element).hasClass('slide')) { i.default(f).addClass(o), u.reflow(f), i.default(s).addClass(n), i.default(f).addClass(n); const p = u.getTransitionDurationFromElement(s); i.default(s).one(u.TRANSITION_END, (() => { i.default(f).removeClass(`${n} ${o}`).addClass(T), i.default(s).removeClass(`active ${o} ${n}`), a._isSliding = !1, setTimeout((() => i.default(a._element).trigger(h)), 0) })).emulateTransitionEnd(p) } else i.default(s).removeClass(T), i.default(f).addClass(T), this._isSliding = !1, i.default(this._element).trigger(h); c && this.cycle()
            }
        }, t._jQueryInterface = function (e) { return this.each((function () { let n = i.default(this).data(E); let o = { ...A, ...i.default(this).data() }; typeof e === 'object' && (o = { ...o, ...e }); const r = typeof e === 'string' ? e : o.slide; if (n || (n = new t(this, o), i.default(this).data(E, n)), typeof e === 'number')n.to(e); else if (typeof r === 'string') { if (typeof n[r] === 'undefined') throw new TypeError(`No method named "${r}"`); n[r]() } else o.interval && o.ride && (n.pause(), n.cycle()) })) }, t._dataApiClickHandler = function (e) { const n = u.getSelectorFromElement(this); if (n) { const o = i.default(n)[0]; if (o && i.default(o).hasClass('carousel')) { const r = { ...i.default(o).data(), ...i.default(this).data() }; const s = this.getAttribute('data-slide-to'); s && (r.interval = !1), t._jQueryInterface.call(i.default(o), r), s && i.default(o).data(E).to(s), e.preventDefault() } } }, r(t, null, [{ key: 'VERSION', get() { return '4.6.1' } }, { key: 'Default', get() { return A } }]), t
    }()); i.default(document).on('click.bs.carousel.data-api', '[data-slide], [data-slide-to]', O._dataApiClickHandler), i.default(window).on('load.bs.carousel.data-api', (() => { for (let t = [].slice.call(document.querySelectorAll('[data-ride="carousel"]')), e = 0, n = t.length; e < n; e++) { const o = i.default(t[e]); O._jQueryInterface.call(o, o.data()) } })), i.default.fn[y] = O._jQueryInterface, i.default.fn[y].Constructor = O, i.default.fn[y].noConflict = function () { return i.default.fn[y] = w, O._jQueryInterface }; const x = 'collapse'; const j = 'bs.collapse'; const L = i.default.fn[x]; const P = 'show'; const F = 'collapse'; const R = 'collapsing'; const H = 'collapsed'; const M = 'width'; const q = '[data-toggle="collapse"]'; const B = { toggle: !0, parent: '' }; const Q = { toggle: 'boolean', parent: '(string|element)' }; const W = (function () { function t(t, e) { this._isTransitioning = !1, this._element = t, this._config = this._getConfig(e), this._triggerArray = [].slice.call(document.querySelectorAll(`[data-toggle="collapse"][href="#${t.id}"],[data-toggle="collapse"][data-target="#${t.id}"]`)); for (let n = [].slice.call(document.querySelectorAll(q)), i = 0, o = n.length; i < o; i++) { const r = n[i]; const a = u.getSelectorFromElement(r); const s = [].slice.call(document.querySelectorAll(a)).filter(((e) => e === t)); a !== null && s.length > 0 && (this._selector = a, this._triggerArray.push(r)) } this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle() } const e = t.prototype; return e.toggle = function () { i.default(this._element).hasClass(P) ? this.hide() : this.show() }, e.show = function () { let e; let n; const o = this; if (!(this._isTransitioning || i.default(this._element).hasClass(P) || (this._parent && (e = [].slice.call(this._parent.querySelectorAll('.show, .collapsing')).filter(((t) => (typeof o._config.parent === 'string' ? t.getAttribute('data-parent') === o._config.parent : t.classList.contains(F))))).length === 0 && (e = null), e && (n = i.default(e).not(this._selector).data(j)) && n._isTransitioning))) { const r = i.default.Event('show.bs.collapse'); if (i.default(this._element).trigger(r), !r.isDefaultPrevented()) { e && (t._jQueryInterface.call(i.default(e).not(this._selector), 'hide'), n || i.default(e).data(j, null)); const a = this._getDimension(); i.default(this._element).removeClass(F).addClass(R), this._element.style[a] = 0, this._triggerArray.length && i.default(this._triggerArray).removeClass(H).attr('aria-expanded', !0), this.setTransitioning(!0); const s = `scroll${a[0].toUpperCase() + a.slice(1)}`; const l = u.getTransitionDurationFromElement(this._element); i.default(this._element).one(u.TRANSITION_END, (() => { i.default(o._element).removeClass(R).addClass('collapse show'), o._element.style[a] = '', o.setTransitioning(!1), i.default(o._element).trigger('shown.bs.collapse') })).emulateTransitionEnd(l), this._element.style[a] = `${this._element[s]}px` } } }, e.hide = function () { const t = this; if (!this._isTransitioning && i.default(this._element).hasClass(P)) { const e = i.default.Event('hide.bs.collapse'); if (i.default(this._element).trigger(e), !e.isDefaultPrevented()) { const n = this._getDimension(); this._element.style[n] = `${this._element.getBoundingClientRect()[n]}px`, u.reflow(this._element), i.default(this._element).addClass(R).removeClass('collapse show'); const o = this._triggerArray.length; if (o > 0) for (let r = 0; r < o; r++) { const a = this._triggerArray[r]; const s = u.getSelectorFromElement(a); s !== null && (i.default([].slice.call(document.querySelectorAll(s))).hasClass(P) || i.default(a).addClass(H).attr('aria-expanded', !1)) } this.setTransitioning(!0), this._element.style[n] = ''; const l = u.getTransitionDurationFromElement(this._element); i.default(this._element).one(u.TRANSITION_END, (() => { t.setTransitioning(!1), i.default(t._element).removeClass(R).addClass(F).trigger('hidden.bs.collapse') })).emulateTransitionEnd(l) } } }, e.setTransitioning = function (t) { this._isTransitioning = t }, e.dispose = function () { i.default.removeData(this._element, j), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null }, e._getConfig = function (t) { return (t = { ...B, ...t }).toggle = Boolean(t.toggle), u.typeCheckConfig(x, t, Q), t }, e._getDimension = function () { return i.default(this._element).hasClass(M) ? M : 'height' }, e._getParent = function () { let e; const n = this; u.isElement(this._config.parent) ? (e = this._config.parent, typeof this._config.parent.jquery !== 'undefined' && (e = this._config.parent[0])) : e = document.querySelector(this._config.parent); const o = `[data-toggle="collapse"][data-parent="${this._config.parent}"]`; const r = [].slice.call(e.querySelectorAll(o)); return i.default(r).each(((e, i) => { n._addAriaAndCollapsedClass(t._getTargetFromElement(i), [i]) })), e }, e._addAriaAndCollapsedClass = function (t, e) { const n = i.default(t).hasClass(P); e.length && i.default(e).toggleClass(H, !n).attr('aria-expanded', n) }, t._getTargetFromElement = function (t) { const e = u.getSelectorFromElement(t); return e ? document.querySelector(e) : null }, t._jQueryInterface = function (e) { return this.each((function () { const n = i.default(this); let o = n.data(j); const r = { ...B, ...n.data(), ...(typeof e === 'object' && e ? e : {}) }; if (!o && r.toggle && typeof e === 'string' && /show|hide/.test(e) && (r.toggle = !1), o || (o = new t(this, r), n.data(j, o)), typeof e === 'string') { if (typeof o[e] === 'undefined') throw new TypeError(`No method named "${e}"`); o[e]() } })) }, r(t, null, [{ key: 'VERSION', get() { return '4.6.1' } }, { key: 'Default', get() { return B } }]), t }()); i.default(document).on('click.bs.collapse.data-api', q, (function (t) { t.currentTarget.tagName === 'A' && t.preventDefault(); const e = i.default(this); const n = u.getSelectorFromElement(this); const o = [].slice.call(document.querySelectorAll(n)); i.default(o).each((function () { const t = i.default(this); const n = t.data(j) ? 'toggle' : e.data(); W._jQueryInterface.call(t, n) })) })), i.default.fn[x] = W._jQueryInterface, i.default.fn[x].Constructor = W, i.default.fn[x].noConflict = function () { return i.default.fn[x] = L, W._jQueryInterface }; const U = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined'; const V = (function () { for (let t = ['Edge', 'Trident', 'Firefox'], e = 0; e < t.length; e += 1) if (U && navigator.userAgent.indexOf(t[e]) >= 0) return 1; return 0 }()); const Y = U && window.Promise ? function (t) { let e = !1; return function () { e || (e = !0, window.Promise.resolve().then((() => { e = !1, t() }))) } } : function (t) { let e = !1; return function () { e || (e = !0, setTimeout((() => { e = !1, t() }), V)) } }; function z(t) { return t && {}.toString.call(t) === '[object Function]' } function K(t, e) { if (t.nodeType !== 1) return []; const n = t.ownerDocument.defaultView.getComputedStyle(t, null); return e ? n[e] : n } function X(t) { return t.nodeName === 'HTML' ? t : t.parentNode || t.host } function G(t) { if (!t) return document.body; switch (t.nodeName) { case 'HTML': case 'BODY': return t.ownerDocument.body; case '#document': return t.body } const e = K(t); const n = e.overflow; const i = e.overflowX; const o = e.overflowY; return /(auto|scroll|overlay)/.test(n + o + i) ? t : G(X(t)) } function $(t) { return t && t.referenceNode ? t.referenceNode : t } const J = U && !(!window.MSInputMethodContext || !document.documentMode); const Z = U && /MSIE 10/.test(navigator.userAgent); function tt(t) { return t === 11 ? J : t === 10 ? Z : J || Z } function et(t) { if (!t) return document.documentElement; for (var e = tt(10) ? document.body : null, n = t.offsetParent || null; n === e && t.nextElementSibling;)n = (t = t.nextElementSibling).offsetParent; const i = n && n.nodeName; return i && i !== 'BODY' && i !== 'HTML' ? ['TH', 'TD', 'TABLE'].indexOf(n.nodeName) !== -1 && K(n, 'position') === 'static' ? et(n) : n : t ? t.ownerDocument.documentElement : document.documentElement } function nt(t) { return t.parentNode !== null ? nt(t.parentNode) : t } function it(t, e) { if (!(t && t.nodeType && e && e.nodeType)) return document.documentElement; const n = t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING; const i = n ? t : e; const o = n ? e : t; const r = document.createRange(); r.setStart(i, 0), r.setEnd(o, 0); let a; let s; const l = r.commonAncestorContainer; if (t !== l && e !== l || i.contains(o)) return (s = (a = l).nodeName) === 'BODY' || s !== 'HTML' && et(a.firstElementChild) !== a ? et(l) : l; const u = nt(t); return u.host ? it(u.host, e) : it(t, nt(e).host) } function ot(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'top'; const n = e === 'top' ? 'scrollTop' : 'scrollLeft'; const i = t.nodeName; if (i === 'BODY' || i === 'HTML') { const o = t.ownerDocument.documentElement; const r = t.ownerDocument.scrollingElement || o; return r[n] } return t[n] } function rt(t, e) { const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const i = ot(e, 'top'); const o = ot(e, 'left'); const r = n ? -1 : 1; return t.top += i * r, t.bottom += i * r, t.left += o * r, t.right += o * r, t } function at(t, e) { const n = e === 'x' ? 'Left' : 'Top'; const i = n === 'Left' ? 'Right' : 'Bottom'; return parseFloat(t[`border${n}Width`]) + parseFloat(t[`border${i}Width`]) } function st(t, e, n, i) { return Math.max(e[`offset${t}`], e[`scroll${t}`], n[`client${t}`], n[`offset${t}`], n[`scroll${t}`], tt(10) ? parseInt(n[`offset${t}`]) + parseInt(i[`margin${t === 'Height' ? 'Top' : 'Left'}`]) + parseInt(i[`margin${t === 'Height' ? 'Bottom' : 'Right'}`]) : 0) } function lt(t) { const e = t.body; const n = t.documentElement; const i = tt(10) && getComputedStyle(n); return { height: st('Height', e, n, i), width: st('Width', e, n, i) } } const ut = function (t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function') }; const ft = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }()); const dt = function (t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n, enumerable: !0, configurable: !0, writable: !0,
        }) : t[e] = n, t
    }; const ct = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }; function ht(t) { return { ...t, right: t.left + t.width, bottom: t.top + t.height } } function pt(t) {
        let e = {}; try { if (tt(10)) { e = t.getBoundingClientRect(); const n = ot(t, 'top'); const i = ot(t, 'left'); e.top += n, e.left += i, e.bottom += n, e.right += i } else e = t.getBoundingClientRect() } catch (t) {} const o = {
            left: e.left, top: e.top, width: e.right - e.left, height: e.bottom - e.top,
        }; const r = t.nodeName === 'HTML' ? lt(t.ownerDocument) : {}; const a = r.width || t.clientWidth || o.width; const s = r.height || t.clientHeight || o.height; let l = t.offsetWidth - a; let u = t.offsetHeight - s; if (l || u) { const f = K(t); l -= at(f, 'x'), u -= at(f, 'y'), o.width -= l, o.height -= u } return ht(o)
    } function mt(t, e) {
        const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const i = tt(10); const o = e.nodeName === 'HTML'; const r = pt(t); const a = pt(e); const s = G(t); const l = K(e); const u = parseFloat(l.borderTopWidth); const f = parseFloat(l.borderLeftWidth); n && o && (a.top = Math.max(a.top, 0), a.left = Math.max(a.left, 0)); let d = ht({
            top: r.top - a.top - u, left: r.left - a.left - f, width: r.width, height: r.height,
        }); if (d.marginTop = 0, d.marginLeft = 0, !i && o) { const c = parseFloat(l.marginTop); const h = parseFloat(l.marginLeft); d.top -= u - c, d.bottom -= u - c, d.left -= f - h, d.right -= f - h, d.marginTop = c, d.marginLeft = h } return (i && !n ? e.contains(s) : e === s && s.nodeName !== 'BODY') && (d = rt(d, e)), d
    } function gt(t) {
        const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = t.ownerDocument.documentElement; const i = mt(t, n); const o = Math.max(n.clientWidth, window.innerWidth || 0); const r = Math.max(n.clientHeight, window.innerHeight || 0); const a = e ? 0 : ot(n); const s = e ? 0 : ot(n, 'left'); const l = {
            top: a - i.top + i.marginTop, left: s - i.left + i.marginLeft, width: o, height: r,
        }; return ht(l)
    } function _t(t) { const e = t.nodeName; if (e === 'BODY' || e === 'HTML') return !1; if (K(t, 'position') === 'fixed') return !0; const n = X(t); return !!n && _t(n) } function vt(t) { if (!t || !t.parentElement || tt()) return document.documentElement; for (var e = t.parentElement; e && K(e, 'transform') === 'none';)e = e.parentElement; return e || document.documentElement } function bt(t, e, n, i) { const o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; let r = { top: 0, left: 0 }; const a = o ? vt(t) : it(t, $(e)); if (i === 'viewport')r = gt(a, o); else { let s = void 0; i === 'scrollParent' ? (s = G(X(e))).nodeName === 'BODY' && (s = t.ownerDocument.documentElement) : s = i === 'window' ? t.ownerDocument.documentElement : i; const l = mt(s, a, o); if (s.nodeName !== 'HTML' || _t(a))r = l; else { const u = lt(t.ownerDocument); const f = u.height; const d = u.width; r.top += l.top - l.marginTop, r.bottom = f + l.top, r.left += l.left - l.marginLeft, r.right = d + l.left } } const c = typeof (n = n || 0) === 'number'; return r.left += c ? n : n.left || 0, r.top += c ? n : n.top || 0, r.right -= c ? n : n.right || 0, r.bottom -= c ? n : n.bottom || 0, r } function yt(t) { return t.width * t.height } function Et(t, e, n, i, o) {
        const r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0; if (t.indexOf('auto') === -1) return t; const a = bt(n, i, r, o); const s = {
            top: { width: a.width, height: e.top - a.top }, right: { width: a.right - e.right, height: a.height }, bottom: { width: a.width, height: a.bottom - e.bottom }, left: { width: e.left - a.left, height: a.height },
        }; const l = Object.keys(s).map(((t) => ({ key: t, ...s[t], area: yt(s[t]) }))).sort(((t, e) => e.area - t.area)); const u = l.filter(((t) => { const e = t.width; const i = t.height; return e >= n.clientWidth && i >= n.clientHeight })); const f = u.length > 0 ? u[0].key : l[0].key; const d = t.split('-')[1]; return f + (d ? `-${d}` : '')
    } function wt(t, e, n) { const i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; const o = i ? vt(e) : it(e, $(n)); return mt(n, o, i) } function Tt(t) { const e = t.ownerDocument.defaultView.getComputedStyle(t); const n = parseFloat(e.marginTop || 0) + parseFloat(e.marginBottom || 0); const i = parseFloat(e.marginLeft || 0) + parseFloat(e.marginRight || 0); return { width: t.offsetWidth + i, height: t.offsetHeight + n } } function Ct(t) {
        const e = {
            left: 'right', right: 'left', bottom: 'top', top: 'bottom',
        }; return t.replace(/left|right|bottom|top/g, ((t) => e[t]))
    } function St(t, e, n) { n = n.split('-')[0]; const i = Tt(t); const o = { width: i.width, height: i.height }; const r = ['right', 'left'].indexOf(n) !== -1; const a = r ? 'top' : 'left'; const s = r ? 'left' : 'top'; const l = r ? 'height' : 'width'; const u = r ? 'width' : 'height'; return o[a] = e[a] + e[l] / 2 - i[l] / 2, o[s] = n === s ? e[s] - i[u] : e[Ct(s)], o } function Nt(t, e) { return Array.prototype.find ? t.find(e) : t.filter(e)[0] } function Dt(t, e, n) { return (void 0 === n ? t : t.slice(0, (function (t, e, n) { if (Array.prototype.findIndex) return t.findIndex(((t) => t.name === n)); const i = Nt(t, ((t) => t.name === n)); return t.indexOf(i) }(t, 0, n)))).forEach(((t) => { t.function && console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); const n = t.function || t.fn; t.enabled && z(n) && (e.offsets.popper = ht(e.offsets.popper), e.offsets.reference = ht(e.offsets.reference), e = n(e, t)) })), e } function At() {
        if (!this.state.isDestroyed) {
            let t = {
                instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: !1, offsets: {},
            }; t.offsets.reference = wt(this.state, this.popper, this.reference, this.options.positionFixed), t.placement = Et(this.options.placement, t.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), t.originalPlacement = t.placement, t.positionFixed = this.options.positionFixed, t.offsets.popper = St(this.popper, t.offsets.reference, t.placement), t.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute', t = Dt(this.modifiers, t), this.state.isCreated ? this.options.onUpdate(t) : (this.state.isCreated = !0, this.options.onCreate(t))
        }
    } function kt(t, e) { return t.some(((t) => { const n = t.name; return t.enabled && n === e })) } function It(t) { for (let e = [!1, 'ms', 'Webkit', 'Moz', 'O'], n = t.charAt(0).toUpperCase() + t.slice(1), i = 0; i < e.length; i++) { const o = e[i]; const r = o ? `${o}${n}` : t; if (typeof document.body.style[r] !== 'undefined') return r } return null } function Ot() { return this.state.isDestroyed = !0, kt(this.modifiers, 'applyStyle') && (this.popper.removeAttribute('x-placement'), this.popper.style.position = '', this.popper.style.top = '', this.popper.style.left = '', this.popper.style.right = '', this.popper.style.bottom = '', this.popper.style.willChange = '', this.popper.style[It('transform')] = ''), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this } function xt(t) { const e = t.ownerDocument; return e ? e.defaultView : window } function jt(t, e, n, i) { const o = t.nodeName === 'BODY'; const r = o ? t.ownerDocument.defaultView : t; r.addEventListener(e, n, { passive: !0 }), o || jt(G(r.parentNode), e, n, i), i.push(r) } function Lt(t, e, n, i) { n.updateBound = i, xt(t).addEventListener('resize', n.updateBound, { passive: !0 }); const o = G(t); return jt(o, 'scroll', n.updateBound, n.scrollParents), n.scrollElement = o, n.eventsEnabled = !0, n } function Pt() { this.state.eventsEnabled || (this.state = Lt(this.reference, this.options, this.state, this.scheduleUpdate)) } function Ft() { let t; let e; this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = (t = this.reference, e = this.state, xt(t).removeEventListener('resize', e.updateBound), e.scrollParents.forEach(((t) => { t.removeEventListener('scroll', e.updateBound) })), e.updateBound = null, e.scrollParents = [], e.scrollElement = null, e.eventsEnabled = !1, e)) } function Rt(t) { return t !== '' && !isNaN(parseFloat(t)) && isFinite(t) } function Ht(t, e) { Object.keys(e).forEach(((n) => { let i = ''; ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(n) !== -1 && Rt(e[n]) && (i = 'px'), t.style[n] = e[n] + i })) } const Mt = U && /Firefox/i.test(navigator.userAgent); function qt(t, e, n) { const i = Nt(t, ((t) => t.name === e)); const o = !!i && t.some(((t) => t.name === n && t.enabled && t.order < i.order)); if (!o) { const r = `\`${e}\``; const a = `\`${n}\``; console.warn(`${a} modifier is required by ${r} modifier in order to work, be sure to include it before ${r}!`) } return o } const Bt = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; const Qt = Bt.slice(3); function Wt(t) { const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = Qt.indexOf(t); const i = Qt.slice(n + 1).concat(Qt.slice(0, n)); return e ? i.reverse() : i } const Ut = {
        placement: 'bottom',
        positionFixed: !1,
        eventsEnabled: !0,
        removeOnDestroy: !1,
        onCreate() {},
        onUpdate() {},
        modifiers: {
            shift: { order: 100, enabled: !0, fn(t) { const e = t.placement; const n = e.split('-')[0]; const i = e.split('-')[1]; if (i) { const o = t.offsets; const r = o.reference; const a = o.popper; const s = ['bottom', 'top'].indexOf(n) !== -1; const l = s ? 'left' : 'top'; const u = s ? 'width' : 'height'; const f = { start: dt({}, l, r[l]), end: dt({}, l, r[l] + r[u] - a[u]) }; t.offsets.popper = { ...a, ...f[i] } } return t } },
            offset: {
                order: 200, enabled: !0, fn(t, e) { let n; const i = e.offset; const o = t.placement; const r = t.offsets; const a = r.popper; const s = r.reference; const l = o.split('-')[0]; return n = Rt(+i) ? [+i, 0] : (function (t, e, n, i) { const o = [0, 0]; const r = ['right', 'left'].indexOf(i) !== -1; const a = t.split(/(\+|\-)/).map(((t) => t.trim())); const s = a.indexOf(Nt(a, ((t) => t.search(/,|\s/) !== -1))); a[s] && a[s].indexOf(',') === -1 && console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.'); const l = /\s*,\s*|\s+/; let u = s !== -1 ? [a.slice(0, s).concat([a[s].split(l)[0]]), [a[s].split(l)[1]].concat(a.slice(s + 1))] : [a]; return u = u.map(((t, i) => { const o = (i === 1 ? !r : r) ? 'height' : 'width'; let a = !1; return t.reduce(((t, e) => (t[t.length - 1] === '' && ['+', '-'].indexOf(e) !== -1 ? (t[t.length - 1] = e, a = !0, t) : a ? (t[t.length - 1] += e, a = !1, t) : t.concat(e))), []).map(((t) => (function (t, e, n, i) { const o = t.match(/((?:\-|\+)?\d*\.?\d*)(.*)/); const r = +o[1]; const a = o[2]; return r ? a.indexOf('%') === 0 ? ht(a === '%p' ? n : i)[e] / 100 * r : a === 'vh' || a === 'vw' ? (a === 'vh' ? Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0)) / 100 * r : r : t }(t, o, e, n)))) })), u.forEach(((t, e) => { t.forEach(((n, i) => { Rt(n) && (o[e] += n * (t[i - 1] === '-' ? -1 : 1)) })) })), o }(i, a, s, l)), l === 'left' ? (a.top += n[0], a.left -= n[1]) : l === 'right' ? (a.top += n[0], a.left += n[1]) : l === 'top' ? (a.left += n[0], a.top -= n[1]) : l === 'bottom' && (a.left += n[0], a.top += n[1]), t.popper = a, t }, offset: 0,
            },
            preventOverflow: {
                order: 300, enabled: !0, fn(t, e) { let n = e.boundariesElement || et(t.instance.popper); t.instance.reference === n && (n = et(n)); const i = It('transform'); const o = t.instance.popper.style; const r = o.top; const a = o.left; const s = o[i]; o.top = '', o.left = '', o[i] = ''; const l = bt(t.instance.popper, t.instance.reference, e.padding, n, t.positionFixed); o.top = r, o.left = a, o[i] = s, e.boundaries = l; const u = e.priority; let f = t.offsets.popper; const d = { primary(t) { let n = f[t]; return f[t] < l[t] && !e.escapeWithReference && (n = Math.max(f[t], l[t])), dt({}, t, n) }, secondary(t) { const n = t === 'right' ? 'left' : 'top'; let i = f[n]; return f[t] > l[t] && !e.escapeWithReference && (i = Math.min(f[n], l[t] - (t === 'right' ? f.width : f.height))), dt({}, n, i) } }; return u.forEach(((t) => { const e = ['left', 'top'].indexOf(t) !== -1 ? 'primary' : 'secondary'; f = { ...f, ...d[e](t) } })), t.offsets.popper = f, t }, priority: ['left', 'right', 'top', 'bottom'], padding: 5, boundariesElement: 'scrollParent',
            },
            keepTogether: { order: 400, enabled: !0, fn(t) { const e = t.offsets; const n = e.popper; const i = e.reference; const o = t.placement.split('-')[0]; const r = Math.floor; const a = ['top', 'bottom'].indexOf(o) !== -1; const s = a ? 'right' : 'bottom'; const l = a ? 'left' : 'top'; const u = a ? 'width' : 'height'; return n[s] < r(i[l]) && (t.offsets.popper[l] = r(i[l]) - n[u]), n[l] > r(i[s]) && (t.offsets.popper[l] = r(i[s])), t } },
            arrow: {
                order: 500, enabled: !0, fn(t, e) { let n; if (!qt(t.instance.modifiers, 'arrow', 'keepTogether')) return t; let i = e.element; if (typeof i === 'string') { if (!(i = t.instance.popper.querySelector(i))) return t } else if (!t.instance.popper.contains(i)) return console.warn('WARNING: `arrow.element` must be child of its popper element!'), t; const o = t.placement.split('-')[0]; const r = t.offsets; const a = r.popper; const s = r.reference; const l = ['left', 'right'].indexOf(o) !== -1; const u = l ? 'height' : 'width'; const f = l ? 'Top' : 'Left'; const d = f.toLowerCase(); const c = l ? 'left' : 'top'; const h = l ? 'bottom' : 'right'; const p = Tt(i)[u]; s[h] - p < a[d] && (t.offsets.popper[d] -= a[d] - (s[h] - p)), s[d] + p > a[h] && (t.offsets.popper[d] += s[d] + p - a[h]), t.offsets.popper = ht(t.offsets.popper); const m = s[d] + s[u] / 2 - p / 2; const g = K(t.instance.popper); const _ = parseFloat(g[`margin${f}`]); const v = parseFloat(g[`border${f}Width`]); let b = m - t.offsets.popper[d] - _ - v; return b = Math.max(Math.min(a[u] - p, b), 0), t.arrowElement = i, t.offsets.arrow = (dt(n = {}, d, Math.round(b)), dt(n, c, ''), n), t }, element: '[x-arrow]',
            },
            flip: {
                order: 600, enabled: !0, fn(t, e) { if (kt(t.instance.modifiers, 'inner')) return t; if (t.flipped && t.placement === t.originalPlacement) return t; const n = bt(t.instance.popper, t.instance.reference, e.padding, e.boundariesElement, t.positionFixed); let i = t.placement.split('-')[0]; let o = Ct(i); let r = t.placement.split('-')[1] || ''; let a = []; switch (e.behavior) { case 'flip': a = [i, o]; break; case 'clockwise': a = Wt(i); break; case 'counterclockwise': a = Wt(i, !0); break; default: a = e.behavior } return a.forEach(((s, l) => { if (i !== s || a.length === l + 1) return t; i = t.placement.split('-')[0], o = Ct(i); const u = t.offsets.popper; const f = t.offsets.reference; const d = Math.floor; const c = i === 'left' && d(u.right) > d(f.left) || i === 'right' && d(u.left) < d(f.right) || i === 'top' && d(u.bottom) > d(f.top) || i === 'bottom' && d(u.top) < d(f.bottom); const h = d(u.left) < d(n.left); const p = d(u.right) > d(n.right); const m = d(u.top) < d(n.top); const g = d(u.bottom) > d(n.bottom); const _ = i === 'left' && h || i === 'right' && p || i === 'top' && m || i === 'bottom' && g; const v = ['top', 'bottom'].indexOf(i) !== -1; const b = !!e.flipVariations && (v && r === 'start' && h || v && r === 'end' && p || !v && r === 'start' && m || !v && r === 'end' && g); const y = !!e.flipVariationsByContent && (v && r === 'start' && p || v && r === 'end' && h || !v && r === 'start' && g || !v && r === 'end' && m); const E = b || y; (c || _ || E) && (t.flipped = !0, (c || _) && (i = a[l + 1]), E && (r = (function (t) { return t === 'end' ? 'start' : t === 'start' ? 'end' : t }(r))), t.placement = i + (r ? `-${r}` : ''), t.offsets.popper = { ...t.offsets.popper, ...St(t.instance.popper, t.offsets.reference, t.placement) }, t = Dt(t.instance.modifiers, t, 'flip')) })), t }, behavior: 'flip', padding: 5, boundariesElement: 'viewport', flipVariations: !1, flipVariationsByContent: !1,
            },
            inner: { order: 700, enabled: !1, fn(t) { const e = t.placement; const n = e.split('-')[0]; const i = t.offsets; const o = i.popper; const r = i.reference; const a = ['left', 'right'].indexOf(n) !== -1; const s = ['top', 'left'].indexOf(n) === -1; return o[a ? 'left' : 'top'] = r[n] - (s ? o[a ? 'width' : 'height'] : 0), t.placement = Ct(e), t.offsets.popper = ht(o), t } },
            hide: { order: 800, enabled: !0, fn(t) { if (!qt(t.instance.modifiers, 'hide', 'preventOverflow')) return t; const e = t.offsets.reference; const n = Nt(t.instance.modifiers, ((t) => t.name === 'preventOverflow')).boundaries; if (e.bottom < n.top || e.left > n.right || e.top > n.bottom || e.right < n.left) { if (!0 === t.hide) return t; t.hide = !0, t.attributes['x-out-of-boundaries'] = '' } else { if (!1 === t.hide) return t; t.hide = !1, t.attributes['x-out-of-boundaries'] = !1 } return t } },
            computeStyle: {
                order: 850,
                enabled: !0,
                fn(t, e) {
                    const n = e.x; const i = e.y; const o = t.offsets.popper; const r = Nt(t.instance.modifiers, ((t) => t.name === 'applyStyle')).gpuAcceleration; void 0 !== r && console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'); let a; let s; const l = void 0 !== r ? r : e.gpuAcceleration; const u = et(t.instance.popper); const f = pt(u); const d = { position: o.position }; const c = (function (t, e) {
                        const n = t.offsets; const i = n.popper; const o = n.reference; const r = Math.round; const a = Math.floor; const s = function (t) { return t }; const l = r(o.width); const u = r(i.width); const f = ['left', "right"].indexOf(t.placement) !== -1; const d = t.placement.indexOf('-') !== -1; const c = e ? f || d || l % 2 == u % 2 ? r : a : s; const h = e ? r : s; return {
                            left: c(l % 2 == 1 && u % 2 == 1 && !d && e ? i.left - 1 : i.left), top: h(i.top), bottom: h(i.bottom), right: c(i.right),
                        }
                    }(t, window.devicePixelRatio < 2 || !Mt)); const h = n === 'bottom' ? 'top' : 'bottom'; const p = i === 'right' ? 'left' : 'right'; const m = It('transform'); if (s = h === 'bottom' ? u.nodeName === 'HTML' ? -u.clientHeight + c.bottom : -f.height + c.bottom : c.top, a = p === 'right' ? u.nodeName === 'HTML' ? -u.clientWidth + c.right : -f.width + c.right : c.left, l && m)d[m] = `translate3d(${a}px, ${s}px, 0)`, d[h] = 0, d[p] = 0, d.willChange = 'transform'; else { const g = h === 'bottom' ? -1 : 1; const _ = p === 'right' ? -1 : 1; d[h] = s * g, d[p] = a * _, d.willChange = `${h}, ${p}` } const v = { 'x-placement': t.placement }; return t.attributes = { ...v, ...t.attributes }, t.styles = { ...d, ...t.styles }, t.arrowStyles = { ...t.offsets.arrow, ...t.arrowStyles }, t
                },
                gpuAcceleration: !0,
                x: 'bottom',
                y: 'right',
            },
            applyStyle: {
                order: 900, enabled: !0, fn(t) { let e; let n; return Ht(t.instance.popper, t.styles), e = t.instance.popper, n = t.attributes, Object.keys(n).forEach(((t) => { !1 !== n[t] ? e.setAttribute(t, n[t]) : e.removeAttribute(t) })), t.arrowElement && Object.keys(t.arrowStyles).length && Ht(t.arrowElement, t.arrowStyles), t }, onLoad(t, e, n, i, o) { const r = wt(o, e, t, n.positionFixed); const a = Et(n.placement, r, e, t, n.modifiers.flip.boundariesElement, n.modifiers.flip.padding); return e.setAttribute('x-placement', a), Ht(e, { position: n.positionFixed ? 'fixed' : 'absolute' }), n }, gpuAcceleration: void 0,
            },
        },
    }; const Vt = (function () { function t(e, n) { const i = this; const o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; ut(this, t), this.scheduleUpdate = function () { return requestAnimationFrame(i.update) }, this.update = Y(this.update.bind(this)), this.options = { ...t.Defaults, ...o }, this.state = { isDestroyed: !1, isCreated: !1, scrollParents: [] }, this.reference = e && e.jquery ? e[0] : e, this.popper = n && n.jquery ? n[0] : n, this.options.modifiers = {}, Object.keys({ ...t.Defaults.modifiers, ...o.modifiers }).forEach(((e) => { i.options.modifiers[e] = { ...t.Defaults.modifiers[e] || {}, ...(o.modifiers ? o.modifiers[e] : {}) } })), this.modifiers = Object.keys(this.options.modifiers).map(((t) => ({ name: t, ...i.options.modifiers[t] }))).sort(((t, e) => t.order - e.order)), this.modifiers.forEach(((t) => { t.enabled && z(t.onLoad) && t.onLoad(i.reference, i.popper, i.options, t, i.state) })), this.update(); const r = this.options.eventsEnabled; r && this.enableEventListeners(), this.state.eventsEnabled = r } return ft(t, [{ key: 'update', value() { return At.call(this) } }, { key: 'destroy', value() { return Ot.call(this) } }, { key: 'enableEventListeners', value() { return Pt.call(this) } }, { key: 'disableEventListeners', value() { return Ft.call(this) } }]), t }()); Vt.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils, Vt.placements = Bt, Vt.Defaults = Ut; const Yt = Vt; const zt = 'dropdown'; const Kt = 'bs.dropdown'; const Xt = i.default.fn[zt]; const Gt = new RegExp('38|40|27'); const $t = 'disabled'; const Jt = 'show'; const Zt = 'dropdown-menu-right'; const te = 'hide.bs.dropdown'; const ee = 'hidden.bs.dropdown'; const ne = 'click.bs.dropdown.data-api'; const ie = 'keydown.bs.dropdown.data-api'; const oe = '[data-toggle="dropdown"]'; const re = '.dropdown-menu'; const ae = {
        offset: 0, flip: !0, boundary: 'scrollParent', reference: 'toggle', display: 'dynamic', popperConfig: null,
    }; const se = {
        offset: '(number|string|function)', flip: 'boolean', boundary: '(string|element)', reference: '(string|element)', display: 'string', popperConfig: '(null|object)',
    }; const le = (function () { function t(t, e) { this._element = t, this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners() } const e = t.prototype; return e.toggle = function () { if (!this._element.disabled && !i.default(this._element).hasClass($t)) { const e = i.default(this._menu).hasClass(Jt); t._clearMenus(), e || this.show(!0) } }, e.show = function (e) { if (void 0 === e && (e = !1), !(this._element.disabled || i.default(this._element).hasClass($t) || i.default(this._menu).hasClass(Jt))) { const n = { relatedTarget: this._element }; const o = i.default.Event('show.bs.dropdown', n); const r = t._getParentFromElement(this._element); if (i.default(r).trigger(o), !o.isDefaultPrevented()) { if (!this._inNavbar && e) { if (typeof Yt === 'undefined') throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let a = this._element; this._config.reference === 'parent' ? a = r : u.isElement(this._config.reference) && (a = this._config.reference, typeof this._config.reference.jquery !== 'undefined' && (a = this._config.reference[0])), this._config.boundary !== 'scrollParent' && i.default(r).addClass('position-static'), this._popper = new Yt(a, this._menu, this._getPopperConfig()) }'ontouchstart' in document.documentElement && i.default(r).closest('.navbar-nav').length === 0 && i.default(document.body).children().on('mouseover', null, i.default.noop), this._element.focus(), this._element.setAttribute('aria-expanded', !0), i.default(this._menu).toggleClass(Jt), i.default(r).toggleClass(Jt).trigger(i.default.Event('shown.bs.dropdown', n)) } } }, e.hide = function () { if (!this._element.disabled && !i.default(this._element).hasClass($t) && i.default(this._menu).hasClass(Jt)) { const e = { relatedTarget: this._element }; const n = i.default.Event(te, e); const o = t._getParentFromElement(this._element); i.default(o).trigger(n), n.isDefaultPrevented() || (this._popper && this._popper.destroy(), i.default(this._menu).toggleClass(Jt), i.default(o).toggleClass(Jt).trigger(i.default.Event(ee, e))) } }, e.dispose = function () { i.default.removeData(this._element, Kt), i.default(this._element).off('.bs.dropdown'), this._element = null, this._menu = null, this._popper !== null && (this._popper.destroy(), this._popper = null) }, e.update = function () { this._inNavbar = this._detectNavbar(), this._popper !== null && this._popper.scheduleUpdate() }, e._addEventListeners = function () { const t = this; i.default(this._element).on('click.bs.dropdown', ((e) => { e.preventDefault(), e.stopPropagation(), t.toggle() })) }, e._getConfig = function (t) { return t = { ...this.constructor.Default, ...i.default(this._element).data(), ...t }, u.typeCheckConfig(zt, t, this.constructor.DefaultType), t }, e._getMenuElement = function () { if (!this._menu) { const e = t._getParentFromElement(this._element); e && (this._menu = e.querySelector(re)) } return this._menu }, e._getPlacement = function () { const t = i.default(this._element.parentNode); let e = 'bottom-start'; return t.hasClass('dropup') ? e = i.default(this._menu).hasClass(Zt) ? 'top-end' : 'top-start' : t.hasClass('dropright') ? e = 'right-start' : t.hasClass('dropleft') ? e = 'left-start' : i.default(this._menu).hasClass(Zt) && (e = 'bottom-end'), e }, e._detectNavbar = function () { return i.default(this._element).closest('.navbar').length > 0 }, e._getOffset = function () { const t = this; const e = {}; return typeof this._config.offset === 'function' ? e.fn = function (e) { return e.offsets = { ...e.offsets, ...t._config.offset(e.offsets, t._element) }, e } : e.offset = this._config.offset, e }, e._getPopperConfig = function () { const t = { placement: this._getPlacement(), modifiers: { offset: this._getOffset(), flip: { enabled: this._config.flip }, preventOverflow: { boundariesElement: this._config.boundary } } }; return this._config.display === 'static' && (t.modifiers.applyStyle = { enabled: !1 }), ({ ...t, ...this._config.popperConfig }) }, t._jQueryInterface = function (e) { return this.each((function () { let n = i.default(this).data(Kt); if (n || (n = new t(this, typeof e === 'object' ? e : null), i.default(this).data(Kt, n)), typeof e === 'string') { if (typeof n[e] === 'undefined') throw new TypeError(`No method named "${e}"`); n[e]() } })) }, t._clearMenus = function (e) { if (!e || e.which !== 3 && (e.type !== 'keyup' || e.which === 9)) for (let n = [].slice.call(document.querySelectorAll(oe)), o = 0, r = n.length; o < r; o++) { const a = t._getParentFromElement(n[o]); const s = i.default(n[o]).data(Kt); const l = { relatedTarget: n[o] }; if (e && e.type === 'click' && (l.clickEvent = e), s) { const u = s._menu; if (i.default(a).hasClass(Jt) && !(e && (e.type === 'click' && /input|textarea/i.test(e.target.tagName) || e.type === 'keyup' && e.which === 9) && i.default.contains(a, e.target))) { const f = i.default.Event(te, l); i.default(a).trigger(f), f.isDefaultPrevented() || ('ontouchstart' in document.documentElement && i.default(document.body).children().off('mouseover', null, i.default.noop), n[o].setAttribute('aria-expanded', 'false'), s._popper && s._popper.destroy(), i.default(u).removeClass(Jt), i.default(a).removeClass(Jt).trigger(i.default.Event(ee, l))) } } } }, t._getParentFromElement = function (t) { let e; const n = u.getSelectorFromElement(t); return n && (e = document.querySelector(n)), e || t.parentNode }, t._dataApiKeydownHandler = function (e) { if (!(/input|textarea/i.test(e.target.tagName) ? e.which === 32 || e.which !== 27 && (e.which !== 40 && e.which !== 38 || i.default(e.target).closest(re).length) : !Gt.test(e.which)) && !this.disabled && !i.default(this).hasClass($t)) { const n = t._getParentFromElement(this); const o = i.default(n).hasClass(Jt); if (o || e.which !== 27) { if (e.preventDefault(), e.stopPropagation(), !o || e.which === 27 || e.which === 32) return e.which === 27 && i.default(n.querySelector(oe)).trigger('focus'), void i.default(this).trigger('click'); const r = [].slice.call(n.querySelectorAll('.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)')).filter(((t) => i.default(t).is(':visible'))); if (r.length !== 0) { let a = r.indexOf(e.target); e.which === 38 && a > 0 && a--, e.which === 40 && a < r.length - 1 && a++, a < 0 && (a = 0), r[a].focus() } } } }, r(t, null, [{ key: 'VERSION', get() { return '4.6.1' } }, { key: 'Default', get() { return ae } }, { key: 'DefaultType', get() { return se } }]), t }()); i.default(document).on(ie, oe, le._dataApiKeydownHandler).on(ie, re, le._dataApiKeydownHandler).on(`${ne} keyup.bs.dropdown.data-api`, le._clearMenus)
        .on(ne, oe, (function (t) { t.preventDefault(), t.stopPropagation(), le._jQueryInterface.call(i.default(this), 'toggle') }))
        .on(ne, '.dropdown form', ((t) => { t.stopPropagation() })), i.default.fn[zt] = le._jQueryInterface, i.default.fn[zt].Constructor = le, i.default.fn[zt].noConflict = function () { return i.default.fn[zt] = Xt, le._jQueryInterface }; const ue = 'bs.modal'; const fe = i.default.fn.modal; const de = 'modal-open'; const ce = 'fade'; const he = 'show'; const pe = 'modal-static'; const me = 'hidden.bs.modal'; const ge = 'show.bs.modal'; const _e = 'focusin.bs.modal'; const ve = 'resize.bs.modal'; const be = 'click.dismiss.bs.modal'; const ye = 'keydown.dismiss.bs.modal'; const Ee = 'mousedown.dismiss.bs.modal'; const we = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'; const Te = {
        backdrop: !0, keyboard: !0, focus: !0, show: !0,
    }; const Ce = {
        backdrop: '(boolean|string)', keyboard: 'boolean', focus: 'boolean', show: 'boolean',
    }; const Se = (function () { function t(t, e) { this._config = this._getConfig(e), this._element = t, this._dialog = t.querySelector('.modal-dialog'), this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollbarWidth = 0 } const e = t.prototype; return e.toggle = function (t) { return this._isShown ? this.hide() : this.show(t) }, e.show = function (t) { const e = this; if (!this._isShown && !this._isTransitioning) { const n = i.default.Event(ge, { relatedTarget: t }); i.default(this._element).trigger(n), n.isDefaultPrevented() || (this._isShown = !0, i.default(this._element).hasClass(ce) && (this._isTransitioning = !0), this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), i.default(this._element).on(be, '[data-dismiss="modal"]', ((t) => e.hide(t))), i.default(this._dialog).on(Ee, (() => { i.default(e._element).one('mouseup.dismiss.bs.modal', ((t) => { i.default(t.target).is(e._element) && (e._ignoreBackdropClick = !0) })) })), this._showBackdrop((() => e._showElement(t)))) } }, e.hide = function (t) { const e = this; if (t && t.preventDefault(), this._isShown && !this._isTransitioning) { const n = i.default.Event('hide.bs.modal'); if (i.default(this._element).trigger(n), this._isShown && !n.isDefaultPrevented()) { this._isShown = !1; const o = i.default(this._element).hasClass(ce); if (o && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), i.default(document).off(_e), i.default(this._element).removeClass(he), i.default(this._element).off(be), i.default(this._dialog).off(Ee), o) { const r = u.getTransitionDurationFromElement(this._element); i.default(this._element).one(u.TRANSITION_END, ((t) => e._hideModal(t))).emulateTransitionEnd(r) } else this._hideModal() } } }, e.dispose = function () { [window, this._element, this._dialog].forEach(((t) => i.default(t).off('.bs.modal'))), i.default(document).off(_e), i.default.removeData(this._element, ue), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null }, e.handleUpdate = function () { this._adjustDialog() }, e._getConfig = function (t) { return t = { ...Te, ...t }, u.typeCheckConfig('modal', t, Ce), t }, e._triggerBackdropTransition = function () { const t = this; const e = i.default.Event('hidePrevented.bs.modal'); if (i.default(this._element).trigger(e), !e.isDefaultPrevented()) { const n = this._element.scrollHeight > document.documentElement.clientHeight; n || (this._element.style.overflowY = 'hidden'), this._element.classList.add(pe); const o = u.getTransitionDurationFromElement(this._dialog); i.default(this._element).off(u.TRANSITION_END), i.default(this._element).one(u.TRANSITION_END, (() => { t._element.classList.remove(pe), n || i.default(t._element).one(u.TRANSITION_END, (() => { t._element.style.overflowY = '' })).emulateTransitionEnd(t._element, o) })).emulateTransitionEnd(o), this._element.focus() } }, e._showElement = function (t) { const e = this; const n = i.default(this._element).hasClass(ce); const o = this._dialog ? this._dialog.querySelector('.modal-body') : null; this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = 'block', this._element.removeAttribute('aria-hidden'), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), i.default(this._dialog).hasClass('modal-dialog-scrollable') && o ? o.scrollTop = 0 : this._element.scrollTop = 0, n && u.reflow(this._element), i.default(this._element).addClass(he), this._config.focus && this._enforceFocus(); const r = i.default.Event('shown.bs.modal', { relatedTarget: t }); const a = function () { e._config.focus && e._element.focus(), e._isTransitioning = !1, i.default(e._element).trigger(r) }; if (n) { const s = u.getTransitionDurationFromElement(this._dialog); i.default(this._dialog).one(u.TRANSITION_END, a).emulateTransitionEnd(s) } else a() }, e._enforceFocus = function () { const t = this; i.default(document).off(_e).on(_e, ((e) => { document !== e.target && t._element !== e.target && i.default(t._element).has(e.target).length === 0 && t._element.focus() })) }, e._setEscapeEvent = function () { const t = this; this._isShown ? i.default(this._element).on(ye, ((e) => { t._config.keyboard && e.which === 27 ? (e.preventDefault(), t.hide()) : t._config.keyboard || e.which !== 27 || t._triggerBackdropTransition() })) : this._isShown || i.default(this._element).off(ye) }, e._setResizeEvent = function () { const t = this; this._isShown ? i.default(window).on(ve, ((e) => t.handleUpdate(e))) : i.default(window).off(ve) }, e._hideModal = function () { const t = this; this._element.style.display = 'none', this._element.setAttribute('aria-hidden', !0), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._isTransitioning = !1, this._showBackdrop((() => { i.default(document.body).removeClass(de), t._resetAdjustments(), t._resetScrollbar(), i.default(t._element).trigger(me) })) }, e._removeBackdrop = function () { this._backdrop && (i.default(this._backdrop).remove(), this._backdrop = null) }, e._showBackdrop = function (t) { const e = this; const n = i.default(this._element).hasClass(ce) ? ce : ''; if (this._isShown && this._config.backdrop) { if (this._backdrop = document.createElement('div'), this._backdrop.className = 'modal-backdrop', n && this._backdrop.classList.add(n), i.default(this._backdrop).appendTo(document.body), i.default(this._element).on(be, ((t) => { e._ignoreBackdropClick ? e._ignoreBackdropClick = !1 : t.target === t.currentTarget && (e._config.backdrop === 'static' ? e._triggerBackdropTransition() : e.hide()) })), n && u.reflow(this._backdrop), i.default(this._backdrop).addClass(he), !t) return; if (!n) return void t(); const o = u.getTransitionDurationFromElement(this._backdrop); i.default(this._backdrop).one(u.TRANSITION_END, t).emulateTransitionEnd(o) } else if (!this._isShown && this._backdrop) { i.default(this._backdrop).removeClass(he); const r = function () { e._removeBackdrop(), t && t() }; if (i.default(this._element).hasClass(ce)) { const a = u.getTransitionDurationFromElement(this._backdrop); i.default(this._backdrop).one(u.TRANSITION_END, r).emulateTransitionEnd(a) } else r() } else t && t() }, e._adjustDialog = function () { const t = this._element.scrollHeight > document.documentElement.clientHeight; !this._isBodyOverflowing && t && (this._element.style.paddingLeft = `${this._scrollbarWidth}px`), this._isBodyOverflowing && !t && (this._element.style.paddingRight = `${this._scrollbarWidth}px`) }, e._resetAdjustments = function () { this._element.style.paddingLeft = '', this._element.style.paddingRight = '' }, e._checkScrollbar = function () { const t = document.body.getBoundingClientRect(); this._isBodyOverflowing = Math.round(t.left + t.right) < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth() }, e._setScrollbar = function () { const t = this; if (this._isBodyOverflowing) { const e = [].slice.call(document.querySelectorAll(we)); const n = [].slice.call(document.querySelectorAll('.sticky-top')); i.default(e).each(((e, n) => { const o = n.style.paddingRight; const r = i.default(n).css('padding-right'); i.default(n).data('padding-right', o).css('padding-right', `${parseFloat(r) + t._scrollbarWidth}px`) })), i.default(n).each(((e, n) => { const o = n.style.marginRight; const r = i.default(n).css('margin-right'); i.default(n).data('margin-right', o).css('margin-right', `${parseFloat(r) - t._scrollbarWidth}px`) })); const o = document.body.style.paddingRight; const r = i.default(document.body).css('padding-right'); i.default(document.body).data('padding-right', o).css('padding-right', `${parseFloat(r) + this._scrollbarWidth}px`) }i.default(document.body).addClass(de) }, e._resetScrollbar = function () { const t = [].slice.call(document.querySelectorAll(we)); i.default(t).each(((t, e) => { const n = i.default(e).data('padding-right'); i.default(e).removeData('padding-right'), e.style.paddingRight = n || '' })); const e = [].slice.call(document.querySelectorAll('.sticky-top')); i.default(e).each(((t, e) => { const n = i.default(e).data('margin-right'); typeof n !== 'undefined' && i.default(e).css('margin-right', n).removeData('margin-right') })); const n = i.default(document.body).data('padding-right'); i.default(document.body).removeData('padding-right'), document.body.style.paddingRight = n || '' }, e._getScrollbarWidth = function () { const t = document.createElement('div'); t.className = 'modal-scrollbar-measure', document.body.appendChild(t); const e = t.getBoundingClientRect().width - t.clientWidth; return document.body.removeChild(t), e }, t._jQueryInterface = function (e, n) { return this.each((function () { let o = i.default(this).data(ue); const r = { ...Te, ...i.default(this).data(), ...(typeof e === 'object' && e ? e : {}) }; if (o || (o = new t(this, r), i.default(this).data(ue, o)), typeof e === 'string') { if (typeof o[e] === 'undefined') throw new TypeError(`No method named "${e}"`); o[e](n) } else r.show && o.show(n) })) }, r(t, null, [{ key: 'VERSION', get() { return '4.6.1' } }, { key: 'Default', get() { return Te } }]), t }()); i.default(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', (function (t) { let e; const n = this; const o = u.getSelectorFromElement(this); o && (e = document.querySelector(o)); const r = i.default(e).data(ue) ? 'toggle' : ({ ...i.default(e).data(), ...i.default(this).data() }); this.tagName !== 'A' && this.tagName !== 'AREA' || t.preventDefault(); var s = i.default(e).one(ge, ((t) => { t.isDefaultPrevented() || s.one(me, (() => { i.default(n).is(':visible') && n.focus() })) })); Se._jQueryInterface.call(i.default(e), r, this) })), i.default.fn.modal = Se._jQueryInterface, i.default.fn.modal.Constructor = Se, i.default.fn.modal.noConflict = function () { return i.default.fn.modal = fe, Se._jQueryInterface }; const Ne = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']; const De = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i; const Ae = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i; function ke(t, e, n) { if (t.length === 0) return t; if (n && typeof n === 'function') return n(t); for (var i = (new window.DOMParser()).parseFromString(t, 'text/html'), o = Object.keys(e), r = [].slice.call(i.body.querySelectorAll('*')), a = function (t, n) { const i = r[t]; const a = i.nodeName.toLowerCase(); if (o.indexOf(i.nodeName.toLowerCase()) === -1) return i.parentNode.removeChild(i), 'continue'; const s = [].slice.call(i.attributes); const l = [].concat(e['*'] || [], e[a] || []); s.forEach(((t) => { (function (t, e) { const n = t.nodeName.toLowerCase(); if (e.indexOf(n) !== -1) return Ne.indexOf(n) === -1 || Boolean(De.test(t.nodeValue) || Ae.test(t.nodeValue)); for (let i = e.filter(((t) => t instanceof RegExp)), o = 0, r = i.length; o < r; o++) if (i[o].test(n)) return !0; return !1 }(t, l)) || i.removeAttribute(t.nodeName) })) }, s = 0, l = r.length; s < l; s++)a(s); return i.body.innerHTML } const Ie = 'tooltip'; const Oe = 'bs.tooltip'; const xe = i.default.fn.tooltip; const je = new RegExp('(^|\\s)bs-tooltip\\S+', 'g'); const Le = ['sanitize', 'whiteList', 'sanitizeFn']; const Pe = 'fade'; const Fe = 'show'; const Re = 'show'; const He = 'out'; const Me = 'hover'; const qe = 'focus'; const Be = {
        AUTO: 'auto', TOP: 'top', RIGHT: 'right', BOTTOM: 'bottom', LEFT: 'left',
    }; const Qe = {
        animation: !0,
        template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: !1,
        selector: !1,
        placement: 'top',
        offset: 0,
        container: !1,
        fallbackPlacement: 'flip',
        boundary: 'scrollParent',
        customClass: '',
        sanitize: !0,
        sanitizeFn: null,
        whiteList: {
            '*': ['class', 'dir', 'id', 'lang', 'role', /^aria-[\w-]*$/i], a: ['target', 'href', 'title', 'rel'], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ['src', 'srcset', 'alt', 'title', 'width', 'height'], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [],
        },
        popperConfig: null,
    }; const We = {
        animation: 'boolean', template: 'string', title: '(string|element|function)', trigger: 'string', delay: '(number|object)', html: 'boolean', selector: '(string|boolean)', placement: '(string|function)', offset: '(number|string|function)', container: '(string|element|boolean)', fallbackPlacement: '(string|array)', boundary: '(string|element)', customClass: '(string|function)', sanitize: 'boolean', sanitizeFn: '(null|function)', whiteList: 'object', popperConfig: '(null|object)',
    }; const Ue = {
        HIDE: 'hide.bs.tooltip', HIDDEN: 'hidden.bs.tooltip', SHOW: 'show.bs.tooltip', SHOWN: 'shown.bs.tooltip', INSERTED: 'inserted.bs.tooltip', CLICK: 'click.bs.tooltip', FOCUSIN: 'focusin.bs.tooltip', FOCUSOUT: 'focusout.bs.tooltip', MOUSEENTER: 'mouseenter.bs.tooltip', MOUSELEAVE: 'mouseleave.bs.tooltip',
    }; const Ve = (function () {
        function t(t, e) { if (typeof Yt === 'undefined') throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); this._isEnabled = !0, this._timeout = 0, this._hoverState = '', this._activeTrigger = {}, this._popper = null, this.element = t, this.config = this._getConfig(e), this.tip = null, this._setListeners() } const e = t.prototype; return e.enable = function () { this._isEnabled = !0 }, e.disable = function () { this._isEnabled = !1 }, e.toggleEnabled = function () { this._isEnabled = !this._isEnabled }, e.toggle = function (t) { if (this._isEnabled) if (t) { const e = this.constructor.DATA_KEY; let n = i.default(t.currentTarget).data(e); n || (n = new this.constructor(t.currentTarget, this._getDelegateConfig()), i.default(t.currentTarget).data(e, n)), n._activeTrigger.click = !n._activeTrigger.click, n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n) } else { if (i.default(this.getTipElement()).hasClass(Fe)) return void this._leave(null, this); this._enter(null, this) } }, e.dispose = function () { clearTimeout(this._timeout), i.default.removeData(this.element, this.constructor.DATA_KEY), i.default(this.element).off(this.constructor.EVENT_KEY), i.default(this.element).closest('.modal').off('hide.bs.modal', this._hideModalHandler), this.tip && i.default(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, this._activeTrigger = null, this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null }, e.show = function () { const t = this; if (i.default(this.element).css('display') === 'none') throw new Error('Please use show on visible elements'); const e = i.default.Event(this.constructor.Event.SHOW); if (this.isWithContent() && this._isEnabled) { i.default(this.element).trigger(e); const n = u.findShadowRoot(this.element); const o = i.default.contains(n !== null ? n : this.element.ownerDocument.documentElement, this.element); if (e.isDefaultPrevented() || !o) return; const r = this.getTipElement(); const a = u.getUID(this.constructor.NAME); r.setAttribute('id', a), this.element.setAttribute('aria-describedby', a), this.setContent(), this.config.animation && i.default(r).addClass(Pe); const s = typeof this.config.placement === 'function' ? this.config.placement.call(this, r, this.element) : this.config.placement; const l = this._getAttachment(s); this.addAttachmentClass(l); const f = this._getContainer(); i.default(r).data(this.constructor.DATA_KEY, this), i.default.contains(this.element.ownerDocument.documentElement, this.tip) || i.default(r).appendTo(f), i.default(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new Yt(this.element, r, this._getPopperConfig(l)), i.default(r).addClass(Fe), i.default(r).addClass(this.config.customClass), 'ontouchstart' in document.documentElement && i.default(document.body).children().on('mouseover', null, i.default.noop); const d = function () { t.config.animation && t._fixTransition(); const e = t._hoverState; t._hoverState = null, i.default(t.element).trigger(t.constructor.Event.SHOWN), e === He && t._leave(null, t) }; if (i.default(this.tip).hasClass(Pe)) { const c = u.getTransitionDurationFromElement(this.tip); i.default(this.tip).one(u.TRANSITION_END, d).emulateTransitionEnd(c) } else d() } }, e.hide = function (t) { const e = this; const n = this.getTipElement(); const o = i.default.Event(this.constructor.Event.HIDE); const r = function () { e._hoverState !== Re && n.parentNode && n.parentNode.removeChild(n), e._cleanTipClass(), e.element.removeAttribute('aria-describedby'), i.default(e.element).trigger(e.constructor.Event.HIDDEN), e._popper !== null && e._popper.destroy(), t && t() }; if (i.default(this.element).trigger(o), !o.isDefaultPrevented()) { if (i.default(n).removeClass(Fe), 'ontouchstart' in document.documentElement && i.default(document.body).children().off('mouseover', null, i.default.noop), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, i.default(this.tip).hasClass(Pe)) { const a = u.getTransitionDurationFromElement(n); i.default(n).one(u.TRANSITION_END, r).emulateTransitionEnd(a) } else r(); this._hoverState = '' } }, e.update = function () { this._popper !== null && this._popper.scheduleUpdate() }, e.isWithContent = function () { return Boolean(this.getTitle()) }, e.addAttachmentClass = function (t) { i.default(this.getTipElement()).addClass(`bs-tooltip-${t}`) }, e.getTipElement = function () { return this.tip = this.tip || i.default(this.config.template)[0], this.tip }, e.setContent = function () { const t = this.getTipElement(); this.setElementContent(i.default(t.querySelectorAll('.tooltip-inner')), this.getTitle()), i.default(t).removeClass('fade show') }, e.setElementContent = function (t, e) { typeof e !== 'object' || !e.nodeType && !e.jquery ? this.config.html ? (this.config.sanitize && (e = ke(e, this.config.whiteList, this.config.sanitizeFn)), t.html(e)) : t.text(e) : this.config.html ? i.default(e).parent().is(t) || t.empty().append(e) : t.text(i.default(e).text()) }, e.getTitle = function () { let t = this.element.getAttribute('data-original-title'); return t || (t = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title), t }, e._getPopperConfig = function (t) {
            const e = this; return {
                placement: t,
                modifiers: {
                    offset: this._getOffset(), flip: { behavior: this.config.fallbackPlacement }, arrow: { element: '.arrow' }, preventOverflow: { boundariesElement: this.config.boundary },
                },
                onCreate(t) { t.originalPlacement !== t.placement && e._handlePopperPlacementChange(t) },
                onUpdate(t) { return e._handlePopperPlacementChange(t) },
                ...this.config.popperConfig,
            }
        }, e._getOffset = function () { const t = this; const e = {}; return typeof this.config.offset === 'function' ? e.fn = function (e) { return e.offsets = { ...e.offsets, ...t.config.offset(e.offsets, t.element) }, e } : e.offset = this.config.offset, e }, e._getContainer = function () { return !1 === this.config.container ? document.body : u.isElement(this.config.container) ? i.default(this.config.container) : i.default(document).find(this.config.container) }, e._getAttachment = function (t) { return Be[t.toUpperCase()] }, e._setListeners = function () { const t = this; this.config.trigger.split(' ').forEach(((e) => { if (e === 'click')i.default(t.element).on(t.constructor.Event.CLICK, t.config.selector, ((e) => t.toggle(e))); else if (e !== 'manual') { const n = e === Me ? t.constructor.Event.MOUSEENTER : t.constructor.Event.FOCUSIN; const o = e === Me ? t.constructor.Event.MOUSELEAVE : t.constructor.Event.FOCUSOUT; i.default(t.element).on(n, t.config.selector, ((e) => t._enter(e))).on(o, t.config.selector, ((e) => t._leave(e))) } })), this._hideModalHandler = function () { t.element && t.hide() }, i.default(this.element).closest('.modal').on('hide.bs.modal', this._hideModalHandler), this.config.selector ? this.config = { ...this.config, trigger: 'manual', selector: '' } : this._fixTitle() }, e._fixTitle = function () { const t = typeof this.element.getAttribute('data-original-title'); (this.element.getAttribute('title') || t !== 'string') && (this.element.setAttribute('data-original-title', this.element.getAttribute('title') || ''), this.element.setAttribute('title', '')) }, e._enter = function (t, e) { const n = this.constructor.DATA_KEY; (e = e || i.default(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), i.default(t.currentTarget).data(n, e)), t && (e._activeTrigger[t.type === 'focusin' ? qe : Me] = !0), i.default(e.getTipElement()).hasClass(Fe) || e._hoverState === Re ? e._hoverState = Re : (clearTimeout(e._timeout), e._hoverState = Re, e.config.delay && e.config.delay.show ? e._timeout = setTimeout((() => { e._hoverState === Re && e.show() }), e.config.delay.show) : e.show()) }, e._leave = function (t, e) { const n = this.constructor.DATA_KEY; (e = e || i.default(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), i.default(t.currentTarget).data(n, e)), t && (e._activeTrigger[t.type === 'focusout' ? qe : Me] = !1), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = He, e.config.delay && e.config.delay.hide ? e._timeout = setTimeout((() => { e._hoverState === He && e.hide() }), e.config.delay.hide) : e.hide()) }, e._isWithActiveTrigger = function () { for (const t in this._activeTrigger) if (this._activeTrigger[t]) return !0; return !1 }, e._getConfig = function (t) { const e = i.default(this.element).data(); return Object.keys(e).forEach(((t) => { Le.indexOf(t) !== -1 && delete e[t] })), typeof (t = { ...this.constructor.Default, ...e, ...(typeof t === 'object' && t ? t : {}) }).delay === 'number' && (t.delay = { show: t.delay, hide: t.delay }), typeof t.title === 'number' && (t.title = t.title.toString()), typeof t.content === 'number' && (t.content = t.content.toString()), u.typeCheckConfig(Ie, t, this.constructor.DefaultType), t.sanitize && (t.template = ke(t.template, t.whiteList, t.sanitizeFn)), t }, e._getDelegateConfig = function () { const t = {}; if (this.config) for (const e in this.config) this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]); return t }, e._cleanTipClass = function () { const t = i.default(this.getTipElement()); const e = t.attr('class').match(je); e !== null && e.length && t.removeClass(e.join('')) }, e._handlePopperPlacementChange = function (t) { this.tip = t.instance.popper, this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(t.placement)) }, e._fixTransition = function () { const t = this.getTipElement(); const e = this.config.animation; t.getAttribute('x-placement') === null && (i.default(t).removeClass(Pe), this.config.animation = !1, this.hide(), this.show(), this.config.animation = e) }, t._jQueryInterface = function (e) { return this.each((function () { const n = i.default(this); let o = n.data(Oe); const r = typeof e === 'object' && e; if ((o || !/dispose|hide/.test(e)) && (o || (o = new t(this, r), n.data(Oe, o)), typeof e === 'string')) { if (typeof o[e] === 'undefined') throw new TypeError(`No method named "${e}"`); o[e]() } })) }, r(t, null, [{ key: 'VERSION', get() { return '4.6.1' } }, { key: 'Default', get() { return Qe } }, { key: 'NAME', get() { return Ie } }, { key: 'DATA_KEY', get() { return Oe } }, { key: 'Event', get() { return Ue } }, { key: 'EVENT_KEY', get() { return '.bs.tooltip' } }, { key: 'DefaultType', get() { return We } }]), t
    }()); i.default.fn.tooltip = Ve._jQueryInterface, i.default.fn.tooltip.Constructor = Ve, i.default.fn.tooltip.noConflict = function () { return i.default.fn.tooltip = xe, Ve._jQueryInterface }; const Ye = 'bs.popover'; const ze = i.default.fn.popover; const Ke = new RegExp('(^|\\s)bs-popover\\S+', 'g'); const Xe = {
        ...Ve.Default, placement: 'right', trigger: 'click', content: '', template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    }; const Ge = { ...Ve.DefaultType, content: '(string|element|function)' }; const $e = {
        HIDE: 'hide.bs.popover', HIDDEN: 'hidden.bs.popover', SHOW: 'show.bs.popover', SHOWN: 'shown.bs.popover', INSERTED: 'inserted.bs.popover', CLICK: 'click.bs.popover', FOCUSIN: 'focusin.bs.popover', FOCUSOUT: 'focusout.bs.popover', MOUSEENTER: 'mouseenter.bs.popover', MOUSELEAVE: 'mouseleave.bs.popover',
    }; const Je = (function (t) { let e; let n; function o() { return t.apply(this, arguments) || this }n = t, (e = o).prototype = Object.create(n.prototype), e.prototype.constructor = e, s(e, n); const a = o.prototype; return a.isWithContent = function () { return this.getTitle() || this._getContent() }, a.addAttachmentClass = function (t) { i.default(this.getTipElement()).addClass(`bs-popover-${t}`) }, a.getTipElement = function () { return this.tip = this.tip || i.default(this.config.template)[0], this.tip }, a.setContent = function () { const t = i.default(this.getTipElement()); this.setElementContent(t.find('.popover-header'), this.getTitle()); let e = this._getContent(); typeof e === 'function' && (e = e.call(this.element)), this.setElementContent(t.find('.popover-body'), e), t.removeClass('fade show') }, a._getContent = function () { return this.element.getAttribute('data-content') || this.config.content }, a._cleanTipClass = function () { const t = i.default(this.getTipElement()); const e = t.attr('class').match(Ke); e !== null && e.length > 0 && t.removeClass(e.join('')) }, o._jQueryInterface = function (t) { return this.each((function () { let e = i.default(this).data(Ye); const n = typeof t === 'object' ? t : null; if ((e || !/dispose|hide/.test(t)) && (e || (e = new o(this, n), i.default(this).data(Ye, e)), typeof t === 'string')) { if (typeof e[t] === 'undefined') throw new TypeError(`No method named "${t}"`); e[t]() } })) }, r(o, null, [{ key: 'VERSION', get() { return '4.6.1' } }, { key: 'Default', get() { return Xe } }, { key: 'NAME', get() { return 'popover' } }, { key: 'DATA_KEY', get() { return Ye } }, { key: 'Event', get() { return $e } }, { key: 'EVENT_KEY', get() { return '.bs.popover' } }, { key: 'DefaultType', get() { return Ge } }]), o }(Ve)); i.default.fn.popover = Je._jQueryInterface, i.default.fn.popover.Constructor = Je, i.default.fn.popover.noConflict = function () { return i.default.fn.popover = ze, Je._jQueryInterface }; const Ze = 'scrollspy'; const tn = 'bs.scrollspy'; const en = i.default.fn[Ze]; const nn = 'active'; const on = 'position'; const rn = '.nav, .list-group'; const an = { offset: 10, method: 'auto', target: '' }; const sn = { offset: 'number', method: 'string', target: '(string|element)' }; const ln = (function () {
        function t(t, e) { const n = this; this._element = t, this._scrollElement = t.tagName === 'BODY' ? window : t, this._config = this._getConfig(e), this._selector = `${this._config.target} .nav-link,${this._config.target} .list-group-item,${this._config.target} .dropdown-item`, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, i.default(this._scrollElement).on('scroll.bs.scrollspy', ((t) => n._process(t))), this.refresh(), this._process() } const e = t.prototype; return e.refresh = function () {
            const t = this; const e = this._scrollElement === this._scrollElement.window ? 'offset' : on; const n = this._config.method === 'auto' ? e : this._config.method; const o = n === on ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), [].slice.call(document.querySelectorAll(this._selector)).map(((t) => { let e; const r = u.getSelectorFromElement(t); if (r && (e = document.querySelector(r)), e) { const a = e.getBoundingClientRect(); if (a.width || a.height) return [i.default(e)[n]().top + o, r] } return null })).filter(((t) => t)).sort(((t, e) => t[0] - e[0]))
                .forEach(((e) => { t._offsets.push(e[0]), t._targets.push(e[1]) }))
        }, e.dispose = function () { i.default.removeData(this._element, tn), i.default(this._scrollElement).off('.bs.scrollspy'), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null }, e._getConfig = function (t) { if (typeof (t = { ...an, ...(typeof t === 'object' && t ? t : {}) }).target !== 'string' && u.isElement(t.target)) { let e = i.default(t.target).attr('id'); e || (e = u.getUID(Ze), i.default(t.target).attr('id', e)), t.target = `#${e}` } return u.typeCheckConfig(Ze, t, sn), t }, e._getScrollTop = function () { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop }, e._getScrollHeight = function () { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) }, e._getOffsetHeight = function () { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height }, e._process = function () { const t = this._getScrollTop() + this._config.offset; const e = this._getScrollHeight(); const n = this._config.offset + e - this._getOffsetHeight(); if (this._scrollHeight !== e && this.refresh(), t >= n) { const i = this._targets[this._targets.length - 1]; this._activeTarget !== i && this._activate(i) } else { if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear(); for (let o = this._offsets.length; o--;) this._activeTarget !== this._targets[o] && t >= this._offsets[o] && (typeof this._offsets[o + 1] === 'undefined' || t < this._offsets[o + 1]) && this._activate(this._targets[o]) } }, e._activate = function (t) { this._activeTarget = t, this._clear(); const e = this._selector.split(',').map(((e) => `${e}[data-target="${t}"],${e}[href="${t}"]`)); const n = i.default([].slice.call(document.querySelectorAll(e.join(',')))); n.hasClass('dropdown-item') ? (n.closest('.dropdown').find('.dropdown-toggle').addClass(nn), n.addClass(nn)) : (n.addClass(nn), n.parents(rn).prev('.nav-link, .list-group-item').addClass(nn), n.parents(rn).prev('.nav-item').children('.nav-link').addClass(nn)), i.default(this._scrollElement).trigger('activate.bs.scrollspy', { relatedTarget: t }) }, e._clear = function () { [].slice.call(document.querySelectorAll(this._selector)).filter(((t) => t.classList.contains(nn))).forEach(((t) => t.classList.remove(nn))) }, t._jQueryInterface = function (e) { return this.each((function () { let n = i.default(this).data(tn); if (n || (n = new t(this, typeof e === 'object' && e), i.default(this).data(tn, n)), typeof e === 'string') { if (typeof n[e] === 'undefined') throw new TypeError(`No method named "${e}"`); n[e]() } })) }, r(t, null, [{ key: 'VERSION', get() { return '4.6.1' } }, { key: 'Default', get() { return an } }]), t
    }()); i.default(window).on('load.bs.scrollspy.data-api', (() => { for (let t = [].slice.call(document.querySelectorAll('[data-spy="scroll"]')), e = t.length; e--;) { const n = i.default(t[e]); ln._jQueryInterface.call(n, n.data()) } })), i.default.fn[Ze] = ln._jQueryInterface, i.default.fn[Ze].Constructor = ln, i.default.fn[Ze].noConflict = function () { return i.default.fn[Ze] = en, ln._jQueryInterface }; const un = 'bs.tab'; const fn = i.default.fn.tab; const dn = 'active'; const cn = 'fade'; const hn = 'show'; const pn = '.active'; const mn = '> li > .active'; const gn = (function () { function t(t) { this._element = t } const e = t.prototype; return e.show = function () { const t = this; if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && i.default(this._element).hasClass(dn) || i.default(this._element).hasClass('disabled'))) { let e; let n; const o = i.default(this._element).closest('.nav, .list-group')[0]; const r = u.getSelectorFromElement(this._element); if (o) { const a = o.nodeName === 'UL' || o.nodeName === 'OL' ? mn : pn; n = (n = i.default.makeArray(i.default(o).find(a)))[n.length - 1] } const s = i.default.Event('hide.bs.tab', { relatedTarget: this._element }); const l = i.default.Event('show.bs.tab', { relatedTarget: n }); if (n && i.default(n).trigger(s), i.default(this._element).trigger(l), !l.isDefaultPrevented() && !s.isDefaultPrevented()) { r && (e = document.querySelector(r)), this._activate(this._element, o); const f = function () { const e = i.default.Event('hidden.bs.tab', { relatedTarget: t._element }); const o = i.default.Event('shown.bs.tab', { relatedTarget: n }); i.default(n).trigger(e), i.default(t._element).trigger(o) }; e ? this._activate(e, e.parentNode, f) : f() } } }, e.dispose = function () { i.default.removeData(this._element, un), this._element = null }, e._activate = function (t, e, n) { const o = this; const r = (!e || e.nodeName !== 'UL' && e.nodeName !== 'OL' ? i.default(e).children(pn) : i.default(e).find(mn))[0]; const a = n && r && i.default(r).hasClass(cn); const s = function () { return o._transitionComplete(t, r, n) }; if (r && a) { const l = u.getTransitionDurationFromElement(r); i.default(r).removeClass(hn).one(u.TRANSITION_END, s).emulateTransitionEnd(l) } else s() }, e._transitionComplete = function (t, e, n) { if (e) { i.default(e).removeClass(dn); const o = i.default(e.parentNode).find('> .dropdown-menu .active')[0]; o && i.default(o).removeClass(dn), e.getAttribute('role') === 'tab' && e.setAttribute('aria-selected', !1) }i.default(t).addClass(dn), t.getAttribute('role') === 'tab' && t.setAttribute('aria-selected', !0), u.reflow(t), t.classList.contains(cn) && t.classList.add(hn); let r = t.parentNode; if (r && r.nodeName === 'LI' && (r = r.parentNode), r && i.default(r).hasClass('dropdown-menu')) { const a = i.default(t).closest('.dropdown')[0]; if (a) { const s = [].slice.call(a.querySelectorAll('.dropdown-toggle')); i.default(s).addClass(dn) }t.setAttribute('aria-expanded', !0) }n && n() }, t._jQueryInterface = function (e) { return this.each((function () { const n = i.default(this); let o = n.data(un); if (o || (o = new t(this), n.data(un, o)), typeof e === 'string') { if (typeof o[e] === 'undefined') throw new TypeError(`No method named "${e}"`); o[e]() } })) }, r(t, null, [{ key: 'VERSION', get() { return '4.6.1' } }]), t }()); i.default(document).on('click.bs.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]', (function (t) { t.preventDefault(), gn._jQueryInterface.call(i.default(this), 'show') })), i.default.fn.tab = gn._jQueryInterface, i.default.fn.tab.Constructor = gn, i.default.fn.tab.noConflict = function () { return i.default.fn.tab = fn, gn._jQueryInterface }; const _n = 'bs.toast'; const vn = i.default.fn.toast; const bn = 'hide'; const yn = 'show'; const En = 'showing'; const wn = 'click.dismiss.bs.toast'; const Tn = { animation: !0, autohide: !0, delay: 500 }; const Cn = { animation: 'boolean', autohide: 'boolean', delay: 'number' }; const Sn = (function () { function t(t, e) { this._element = t, this._config = this._getConfig(e), this._timeout = null, this._setListeners() } const e = t.prototype; return e.show = function () { const t = this; const e = i.default.Event('show.bs.toast'); if (i.default(this._element).trigger(e), !e.isDefaultPrevented()) { this._clearTimeout(), this._config.animation && this._element.classList.add('fade'); const n = function () { t._element.classList.remove(En), t._element.classList.add(yn), i.default(t._element).trigger('shown.bs.toast'), t._config.autohide && (t._timeout = setTimeout((() => { t.hide() }), t._config.delay)) }; if (this._element.classList.remove(bn), u.reflow(this._element), this._element.classList.add(En), this._config.animation) { const o = u.getTransitionDurationFromElement(this._element); i.default(this._element).one(u.TRANSITION_END, n).emulateTransitionEnd(o) } else n() } }, e.hide = function () { if (this._element.classList.contains(yn)) { const t = i.default.Event('hide.bs.toast'); i.default(this._element).trigger(t), t.isDefaultPrevented() || this._close() } }, e.dispose = function () { this._clearTimeout(), this._element.classList.contains(yn) && this._element.classList.remove(yn), i.default(this._element).off(wn), i.default.removeData(this._element, _n), this._element = null, this._config = null }, e._getConfig = function (t) { return t = { ...Tn, ...i.default(this._element).data(), ...(typeof t === 'object' && t ? t : {}) }, u.typeCheckConfig('toast', t, this.constructor.DefaultType), t }, e._setListeners = function () { const t = this; i.default(this._element).on(wn, '[data-dismiss="toast"]', (() => t.hide())) }, e._close = function () { const t = this; const e = function () { t._element.classList.add(bn), i.default(t._element).trigger('hidden.bs.toast') }; if (this._element.classList.remove(yn), this._config.animation) { const n = u.getTransitionDurationFromElement(this._element); i.default(this._element).one(u.TRANSITION_END, e).emulateTransitionEnd(n) } else e() }, e._clearTimeout = function () { clearTimeout(this._timeout), this._timeout = null }, t._jQueryInterface = function (e) { return this.each((function () { const n = i.default(this); let o = n.data(_n); if (o || (o = new t(this, typeof e === 'object' && e), n.data(_n, o)), typeof e === 'string') { if (typeof o[e] === 'undefined') throw new TypeError(`No method named "${e}"`); o[e](this) } })) }, r(t, null, [{ key: 'VERSION', get() { return '4.6.1' } }, { key: 'DefaultType', get() { return Cn } }, { key: 'Default', get() { return Tn } }]), t }()); i.default.fn.toast = Sn._jQueryInterface, i.default.fn.toast.Constructor = Sn, i.default.fn.toast.noConflict = function () { return i.default.fn.toast = vn, Sn._jQueryInterface }, t.Alert = c, t.Button = b, t.Carousel = O, t.Collapse = W, t.Dropdown = le, t.Modal = Se, t.Popover = Je, t.Scrollspy = ln, t.Tab = gn, t.Toast = Sn, t.Tooltip = Ve, t.Util = u, Object.defineProperty(t, '__esModule', { value: !0 })
})));
// # sourceMappingURL=bootstrap.bundle.min.js.map
